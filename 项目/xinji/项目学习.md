# 一、认证模块
## 1.2 用户登录/注册
### 1.2.1前端(登陆)
#### **scr/views/Login.vue**
```javascript
	// 向后端发送登录请求
	const res = await login(form.value.phone, form.value.code)
```

#### **src/api/user.ts**
```javascript
export const login = (phone: string, code: string) => {
	// <ApiResponse<LoginResponse>>：指定响应数据的类型结构
	// 实际请求URL:baseURL+'/auth/login'
	// 请求体数据：{ phone, code }
	return request.post<ApiResponse<LoginResponse>>('/auth/login', { phone, code })

}
```

#### **src/api/request.ts**
```javascript
// 创建axios实例

const request = axios.create({
	baseURL: '/api',
	timeout: 30000,
	headers: {
	'Content-Type': 'application/json'
	}
})
```

#### **src/types/index.ts**
```javascript
export interface ApiResponse<T> {
	code: number
	message: string
	data: T
	timestamp: string
}

export interface LoginResponse {
	token: string
	expiresIn: number
	user: {
		id: string
		phone: string
		memberStatus: string
		memberExpireTime?: string
		registerTime: string
	}
}
```

### 1.2.2 后端（登陆）
#### login(.../controller/AuthController.java)
```java
@PostMapping("/login")  
public ApiResponse<LoginResponse> login(@Valid @RequestBody LoginRequest request) {  
    LoginResponse response = userService.login(request);  
    return ApiResponse.success("登录成功", response);  
}
```

#### 补充: @Valid 和 @Validated
- @Valid 对类对象进行数据校验，使用方法：
```java
@Data  
public class LoginRequest {  
      
    @NotBlank(message = "手机号不能为空")  
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式错误")  
    private String phone;  
      
    @NotBlank(message = "验证码不能为空")  
    @Size(min = 6, max = 6, message = "验证码必须为6位")  
    private String code;  
}
```
- @Validated
```java
@RestController
@Validated  // 在类上添加此注解
public class UserController {
    
    // 对单个参数进行校验
    @GetMapping("/user/{id}")
    public Result getUserById(
        @PathVariable @Min(value = 1, message = "ID必须大于0") Long id,
        @RequestParam @NotBlank String name) {
        return userService.getUserById(id, name);
    }
}
```
---
#### login(.../service/impl/UserServiceImpl.java)
```java
@Override  
@Transactional  
public LoginResponse login(LoginRequest request) {  
    String phone = request.getPhone();  
    String code = request.getCode();  
      
    // 验证验证码
    String codeKey = CODE_KEY_PREFIX + phone;  
    Object storedCode = redisTemplate.opsForValue().get(codeKey);  
      
    if (storedCode == null || !code.equals(storedCode.toString())) {  
        throw BusinessException.badRequest("验证码错误或已过期");  
    }  
      
    // 验证成功，删除验证码  
    redisTemplate.delete(codeKey);  
      
    // 查询或创建用户  
    String phoneHash = PhoneUtil.hash(phone);  
    User user = userRepository.findByPhoneHash(phoneHash);  
      
    boolean isNewUser = false;  
    if (user == null) {  
        // 新用户注册  
        user = new User();  
        user.setPhone(aesUtil.encrypt(phone));  
        user.setPhoneHash(phoneHash);  
        user.setMemberStatus("FREE");  
        user.setDeleted(0);  
        userRepository.insert(user);  
        isNewUser = true;  
        log.info("新用户注册: {}", PhoneUtil.mask(phone));  
    }  
      
    // 更新最后登录时间  
    user.setLastLoginTime(LocalDateTime.now());  
    userRepository.updateById(user);  
      
    // 生成JWT Token  
    String token = jwtUtil.generateToken(user.getId());  
      
    // 构建响应  
    LoginResponse response = new LoginResponse();  
    response.setToken(token);  
    response.setExpiresIn(jwtUtil.getExpirationSeconds());  
      
    LoginResponse.UserInfo userInfo = new LoginResponse.UserInfo();  
    userInfo.setId(user.getId());  
    userInfo.setPhone(PhoneUtil.mask(phone));  
    userInfo.setMemberStatus(user.getMemberStatus());  
    userInfo.setMemberExpireTime(user.getMemberExpireTime());  
    userInfo.setRegisterTime(user.getRegisterTime());  
    response.setUser(userInfo);  
      
    log.info("用户登录成功: userId={}, isNewUser={}", user.getId(), isNewUser);  
    return response;  
}
```
#### 补充：DigestUtil
```java
/**  
 * 生成手机号哈希(用于数据库查询)  
 */public static String hash(String phone) {  
    return DigestUtil.sha256Hex(phone);  
}
```
**md5和sha256算法的区别**

相同点：

1、都是密码散列函数，加密不可逆。

2、都可以实现对任意长度对象加密，都不能防止碰撞。

_安全性方面：_

1、SHA256（⼜称SHA2）的安全性最⾼，但是耗时要⽐其他两种多很多。

2、md5相对来说比较容易碰撞，安全性没这么高。

_性能方面：_

以⼀个60M的⽂件为测试样本，经过1000次的测试平均值，这两种算法的表现如下：

MD5算法运⾏1000次的平均时间为：226ms

[SHA256算法](https://zhida.zhihu.com/search?content_id=201524285&content_type=Article&match_order=1&q=SHA256%E7%AE%97%E6%B3%95&zhida_source=entity)运⾏1000次的平均时间为：473ms


#### 补充：非对称加密（RSA），对称加密（AES)
- 对称加密算法
加密和解密用到的密钥是相同的，这种加密方式加密速度非常快，适合经常发送数据的场合。缺点是密钥的传输比较麻烦。

- 非对称加密算法
加密和解密用的密钥是不同的，这种加密方式是用数学上的难解问题构造的，通常加密解密的速度比较慢，适合偶尔发送数据的场合。优点是密钥传输方便。常见的非对称加密算法为RSA、ECC和EIGamal。

实际中，一般是通过RSA加密AES的密钥，传输到接收方，接收方解密得到AES密钥，然后发送方和接收方用AES密钥来通信。

```java
@Component  
public class AESUtil {  
      
    @Value("${aes.key}")  
    private String aesKey;  
      
    @Value("${aes.iv}")  
    private String aesIv;  
      
    private AES aes;  
      
    @PostConstruct  
    public void init() {  
        // 确保key和iv为16字节  
        byte[] keyBytes = padOrTrim(aesKey.getBytes(StandardCharsets.UTF_8), 16);  
        byte[] ivBytes = padOrTrim(aesIv.getBytes(StandardCharsets.UTF_8), 16);  
        // 使用 PKCS5Padding (JDK标准支持，与PKCS7Padding在16字节块大小时等效)  
        this.aes = new AES("CBC", "PKCS5Padding", keyBytes, ivBytes);  
    }  
      
    /**  
     * 加密  
     */  
    public String encrypt(String plainText) {  
        if (plainText == null || plainText.isEmpty()) {  
            return plainText;  
        }  
        return aes.encryptBase64(plainText);  
    }  
      
    /**  
     * 解密  
     */  
    public String decrypt(String encryptedText) {  
        if (encryptedText == null || encryptedText.isEmpty()) {  
            return encryptedText;  
        }  
        return aes.decryptStr(encryptedText);  
    }  
      
    /**  
     * 填充或截断到指定长度  
     */  
    private byte[] padOrTrim(byte[] bytes, int length) {  
        byte[] result = new byte[length];  
        System.arraycopy(bytes, 0, result, 0, Math.min(bytes.length, length));  
        return result;  
    }  
}
```
#### 补充：JWT令牌
JWT的组成： （JWT令牌由三个部分组成，三个部分之间使用英文的点来分割）

- 第一部分：Header(头）， 记录令牌类型、签名算法等。 例如：{"alg":"HS256","type":"JWT"}
    
- 第二部分：Payload(有效载荷），携带一些自定义信息、默认信息等。 例如：{"id":"1","username":"Tom"}
    
- 第三部分：Signature(签名），防止Token被篡改、确保安全性。将header、payload，并加入指定秘钥，通过指定签名算法计算而来。
![](项目学习.assets/file-20251224171300899.png)

**问题**：token放进LoginResponse里，为什么不存在数据库中？
答：在前端用的，后端返回给前端后，前端存到本地，每次发送请求时都会带上令牌
##### 代码示例

```java
/**  
 * JWT工具类  
 */  
@Component  
public class JwtUtil {  
      
    @Value("${jwt.secret}")  
    private String secret;  
      
    @Value("${jwt.expiration}")  
    private Long expiration;  
      
    @Value("${jwt.refresh-threshold}")  
    private Long refreshThreshold;  
      
    private SecretKey secretKey;  
      
    @PostConstruct  
    public void init() {  
        this.secretKey = Keys.hmacShaKeyFor(secret.getBytes(StandardCharsets.UTF_8));  
    }  
      
    /**  
     * 生成JWT Token  
     */    
     public String generateToken(String userId) {  
        Date now = new Date();  
        Date expiryDate = new Date(now.getTime() + expiration);  
          
        return Jwts.builder()  
                .subject(userId)  
                .issuedAt(now)  
                .expiration(expiryDate)  
                .signWith(secretKey)  
                .compact();  
    }  
      
    /**  
     * 从Token中获取用户ID  
     */    public String getUserIdFromToken(String token) {  
        Claims claims = parseToken(token);  
        return claims != null ? claims.getSubject() : null;  
    }  
      
    /**  
     * 验证Token是否有效  
     */  
    public boolean validateToken(String token) {  
        try {  
            parseToken(token);  
            return true;  
        } catch (JwtException | IllegalArgumentException e) {  
            return false;  
        }  
    }  
      
    /**  
     * 检查Token是否可以刷新(过期前1天内)  
     */    public boolean canRefresh(String token) {  
        try {  
            Claims claims = parseToken(token);  
            if (claims == null) {  
                return false;  
            }  
            Date expiry = claims.getExpiration();  
            long timeUntilExpiry = expiry.getTime() - System.currentTimeMillis();  
            // 在过期前refreshThreshold毫秒内可以刷新  
            return timeUntilExpiry > 0 && timeUntilExpiry <= refreshThreshold;  
        } catch (ExpiredJwtException e) {  
            // Token已过期但在刷新阈值内，也允许刷新  
            long expiredTime = System.currentTimeMillis() - e.getClaims().getExpiration().getTime();  
            return expiredTime <= 3600000; // 过期1小时内也可刷新  
        } catch (JwtException | IllegalArgumentException e) {  
            return false;  
        }  
    }  
      
    /**  
     * 获取Token过期时间(秒)  
     */    public Long getExpirationSeconds() {  
        return expiration / 1000;  
    }  
      
    /**  
     * 解析Token  
     */    private Claims parseToken(String token) {  
        try {  
            return Jwts.parser()  
                    .verifyWith(secretKey)  
                    .build()  
                    .parseSignedClaims(token)  
                    .getPayload();  
        } catch (ExpiredJwtException e) {  
            throw e; // 让调用方处理过期情况  
        } catch (JwtException | IllegalArgumentException e) {  
            return null;  
        }  
    }  
      
    /**  
     * 从过期Token中获取用户ID(用于刷新)  
     */    public String getUserIdFromExpiredToken(String token) {  
        try {  
            parseToken(token);  
            return null;  
        } catch (ExpiredJwtException e) {  
            return e.getClaims().getSubject();  
        }  
    }  
}
```



### 1.2.3 前端(获取用户信息)
```javascript
const handleLogin = async () => {

	if (!agreed.value) {
	ElMessage.warning('请先同意用户协议和隐私政策')
	return
	}
	
	// 表单校验
	const valid = await formRef.value?.validate().catch(() => false)
	if (!valid) return
	  
	loading.value = true
	try {
		// 向后端发送登录请求	
		const res = await login(form.value.phone, form.value.code)
		
		// 保存Token
		userStore.setToken(res.data.data.token)
		
		// 获取用户信息
		await userStore.fetchUserProfile()
		
		ElMessage.success('登录成功')
		
		// 跳转到目标页面
		const redirect = route.query.redirect as string
		
		router.push(redirect || '/diary')
	
	} catch (error) {
	console.error('登录失败:', error)
	
	} finally {
	loading.value = false
	
	}

}
```

#### userStore.fetchUserProfile() -> getUserProfile
```javascript
/**
* 获取用户信息
*/

export const getUserProfile = () => {
	return request.get<ApiResponse<UserProfile>>('/user/profile').then(res => res.data)
}
```

### 1.2.4 后端(获取用户信息)
#### getProfile(.../controller/UserController.java)
```java

private final UserService userService;  
private final SecurityContext securityContext;
/**  
 * 获取用户信息  
 */  
@GetMapping("/profile")  
public ApiResponse<UserProfileResponse> getProfile() {  
    String userId = securityContext.getCurrentUserId();  
    UserProfileResponse response = userService.getProfile(userId);  
    return ApiResponse.success(response);  
}
```

#### SecurityContext
```java
/**  
 * 安全上下文工具类  
 * 获取当前登录用户信息  
 */  
@Component  
public class SecurityContext {  
      
    /**  
     * 获取当前登录用户  
     */  
    public User getCurrentUser() {  
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();  
        if (authentication != null && authentication.getPrincipal() instanceof User) {  
            return (User) authentication.getPrincipal();  
        }  
        return null;  
    }  
      
    /**  
     * 获取当前登录用户ID  
     */    public String getCurrentUserId() {  
        User user = getCurrentUser();  
        return user != null ? user.getId() : null;  
    }  
      
    /**  
     * 判断当前用户是否为Pro会员  
     */  
    public boolean isProMember() {  
        User user = getCurrentUser();  
        return user != null && "PRO".equals(user.getMemberStatus());  
    }  
      
    /**  
     * 判断是否已登录  
     */  
    public boolean isAuthenticated() {  
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();  
        return authentication != null &&   
               authentication.isAuthenticated() &&   
               authentication.getPrincipal() instanceof User;  
    }  
}
```

#### 补充：SecurityContextHolder
##### 1. 工作模式
- MODE_THREADLOCAL：默认，使用`ThreadLocal`，一个线程使用一个安全上下文
- MODE_GLOBAL：所有线程使用同一个安全上下文
- MODE_INHERITABLETHREADLOCAL：一些应用会有自己的线程创建，并且希望这些新建线程也能使用创建者的安全上下文
##### 2. 配置工作模式
两种方法：
1. 在配置文件中配置：spring.security.strategy
2. 调用`SecurityContextHolder`静态方法`setStrategyName()`

#### 3. 代码例子
```java

// 获取安全上下文对象，就是那个保存在 ThreadLocal 里面的安全上下文对象
// 总是不为null(如果不存在，则创建一个authentication属性为null的empty安全上下文对象)
SecurityContext securityContext = SecurityContextHolder.getContext();

// 获取当前认证了的 principal(当事人),或者 request token (令牌)
// 如果没有认证，会是 null,该例子是认证之后的情况
Authentication authentication = securityContext.getAuthentication()

// 获取当事人信息对象，返回结果是 Object 类型，但实际上可以是应用程序自定义的带有更多应用相关信息的某个类型。
// 很多情况下，该对象是 Spring Security 核心接口 UserDetails 的一个实现类，你可以把 UserDetails 想像
// 成我们数据库中保存的一个用户信息到 SecurityContextHolder 中 Spring Security 需要的用户信息格式的
// 一个适配器。
Object principal = authentication.getPrincipal();
if (principal instanceof UserDetails) {
	String username = ((UserDetails)principal).getUsername();
} else {
	String username = principal.toString();
}

```

项目中的使用：
```java
/**  
 * 获取当前登录用户  
 */  
public User getCurrentUser() {  
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();  
    if (authentication != null && authentication.getPrincipal() instanceof User) {  
        return (User) authentication.getPrincipal();  
    }  
    return null;  
}
```


