# é›¶ã€å…¶ä»–

```bash
g++ -std=c++20 -o2 -Wall $1.cpp -o main
./main < in.txt > out.txt
cat out.txt
```

```c++
int a[N],pos[N];
for(int i=1; i<=n; i++){
    pos[i]=i;
}
sort(a+1, a+1+n, [&](int x, int y)->bool{
    return a[x] < a[y];
})
//a=2,1,13,19,11
//pos=2 1 5 3 4
```



# ä¸€ã€DP

## 1.1 çŠ¶å‹dp

å­é›†æšä¸¾

```c++
// æšä¸¾maskçš„æ‰€æœ‰å­é›†ï¼ˆåŒ…æ‹¬ç©ºé›†å’Œmaskæœ¬èº«ï¼‰
void enumerateSubsets(int mask) {
    for (int sub = mask; ; sub = (sub - 1) & mask) {
        // å¤„ç†å­é›†sub
        System.out.println(sub);
        if (sub == 0) break; // ç»ˆæ­¢æ¡ä»¶
    }
}

// æšä¸¾maskçš„æ‰€æœ‰éç©ºå­é›†
void enumerateNonEmptySubsets(int mask) {
    for (int sub = mask; sub > 0; sub = (sub - 1) & mask) {
        // å¤„ç†éç©ºå­é›†sub
        System.out.println(sub);
    }
}
```



# äºŒã€å›¾

## 2.1 æœ€å°ç¥–å®—æ ‘

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 5e5 + 100;
int n, m, s; // næ˜¯æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ï¼Œsæ˜¯æ ‘æ ¹èŠ‚ç‚¹
int lg[N];

struct node
{
	int to, ne;
}e[N << 1];
int head[N], cnt;
void add(int u, int v)
{
	e[++cnt].to = v;
	e[cnt].ne = head[u];
	head[u] = cnt;
}

int fa[N][20], depth[N]; // æ ¹èŠ‚ç‚¹depthä¸º1
void dfs(int now, int fath)
{
	fa[now][0] = fath, depth[now] = depth[fath] + 1;
	for (int i = 1; i <= lg[depth[now]]; i++)
	{
		fa[now][i] = fa[fa[now][i - 1]][i - 1];
	}
	for (int i = head[now]; i; i = e[i].ne)
	{
		if (e[i].to != fath)
		{
			dfs(e[i].to, now);
		}
	}
}
int LCA(int a, int b)
{
	if (depth[a] < depth[b]) swap(a, b);
	while (depth[a] > depth[b])
	{
		a = fa[a][lg[depth[a] - depth[b]] - 1];
	}
	if (a == b) return a;
	for (int i = lg[depth[a]] - 1; i >= 0; i--)
	{
		if (fa[a][i] != fa[b][i])
		{
			a = fa[a][i];
			b = fa[b][i];
		}
	}
	a = fa[a][0];
	return a;
}

signed main()
{
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n >> m >> s; // æ ‘çš„ç»“ç‚¹ä¸ªæ•°ï¼Œ è¯¢é—®çš„ä¸ªæ•°ï¼Œ æ ‘æ ¹èŠ‚ç‚¹çš„åºå·
	for (int i = 1; i < n; i++)
	{
        int u,v;
		cin >> u >> v;
		add(u, v), add(v, u);
	}
	for (int i = 1; i < N; i++)
	{
		lg[i] = lg[i - 1] + (1 << lg[i-1] == i); //è·å¾—log2(i)+1,å…¶ä¸­log2(i)å‘ä¸‹å–æ•´
	}
	dfs(s, 0);
	while (m--)
	{
        int a,b;
		cin >> a >> b;
		cout << LCA(a, b) << "\n";
	}
}
```

## 2.2 æ ‘ä¸Šå¯å‘å¼åˆå¹¶

> ç»™å‡ºä¸€æ£µ ğ‘›![n](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) ä¸ªèŠ‚ç‚¹ä»¥ 1![1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) ä¸ºæ ¹çš„æ ‘ï¼ŒèŠ‚ç‚¹ ğ‘¢![u](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) çš„é¢œè‰²ä¸º ğ‘~ğ‘¢~![c_u](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œç°åœ¨å¯¹äºæ¯ä¸ªç»“ç‚¹ ğ‘¢![u](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) è¯¢é—®ä»¥ ğ‘¢![u](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) ä¸ºæ ¹çš„å­æ ‘é‡Œä¸€å…±å‡ºç°äº†å¤šå°‘ç§ä¸åŒçš„é¢œè‰²ã€‚
>
> ğ‘› â‰¤ 2 Ã—10^5^![n\le 2\times 10^5](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ã€‚

```cpp
#include <cstdio>
#include <vector>
using namespace std;

constexpr int N = 2e5 + 5;

int n, m;

// g[u]: å­˜å‚¨ä¸ u ç›¸é‚»çš„ç»“ç‚¹
vector<int> g[N];

// sz: å­æ ‘å¤§å°
// big: é‡å„¿å­
// col: ç»“ç‚¹é¢œè‰² ï¼ˆé¢˜ç›®ç”¨ï¼‰
// L[u]: ç»“ç‚¹ u çš„ DFS åº
// R[u]: ç»“ç‚¹ u å­æ ‘ä¸­ç»“ç‚¹çš„ DFS åºçš„æœ€å¤§å€¼
// Node[i]: DFS åºä¸º i çš„ç»“ç‚¹
// totdfn: èŠ‚ç‚¹è®¡æ•°å™¨ï¼Œä¹Ÿæ˜¯å½“å‰éå†è¿‡èŠ‚ç‚¹çš„ DFS åºæœ€å¤§å€¼
// ans: å­˜ç­”æ¡ˆ
// cnt[i]: é¢œè‰²ä¸º i çš„ç»“ç‚¹ä¸ªæ•°
// totColor: ç›®å‰å‡ºç°è¿‡çš„é¢œè‰²ä¸ªæ•° ï¼ˆé¢˜ç›®ç”¨ï¼‰
int sz[N], big[N], col[N], L[N], R[N], Node[N], totdfn;
int ans[N], cnt[N], totColor;

void add(int u) {
  if (cnt[col[u]] == 0) ++totColor;
  cnt[col[u]]++;
}

void del(int u) {
  cnt[col[u]]--;
  if (cnt[col[u]] == 0) --totColor;
}

int getAns() { return totColor; }

void dfs0(int u, int p) {
  L[u] = ++totdfn;
  Node[totdfn] = u;
  sz[u] = 1;
  for (int v : g[u])
    if (v != p) {
      dfs0(v, u);
      sz[u] += sz[v];
      if (!big[u] || sz[big[u]] < sz[v]) big[u] = v;
    }
  R[u] = totdfn;
}

void dfs1(int u, int p, bool keep) {
  // è®¡ç®—è½»å„¿å­çš„ç­”æ¡ˆ
  for (int v : g[u])
    if (v != p && v != big[u]) {
      dfs1(v, u, false);
    }
  // è®¡ç®—é‡å„¿å­ç­”æ¡ˆå¹¶ä¿ç•™è®¡ç®—è¿‡ç¨‹ä¸­çš„æ•°æ®ï¼ˆç”¨äºç»§æ‰¿ï¼‰
  if (big[u]) {
    dfs1(big[u], u, true);
  }
  for (int v : g[u])
    if (v != p && v != big[u]) {
      // å­æ ‘ç»“ç‚¹çš„ DFS åºæ„æˆä¸€æ®µè¿ç»­åŒºé—´ï¼Œå¯ä»¥ç›´æ¥éå†
      for (int i = L[v]; i <= R[v]; i++) {
        add(Node[i]);
      }
    }
  add(u);
  ans[u] = getAns();
  if (!keep) {
    for (int i = L[u]; i <= R[u]; i++) {
      del(Node[i]);
    }
  }
}

int main() {
  scanf("%d", &n);
  for (int i = 1; i < n; i++) {
    int u, v;
    scanf("%d%d", &u, &v);
    g[u].push_back(v);
    g[v].push_back(u);
  }
  for (int i = 1; i <= n; i++) scanf("%d", &col[i]);
  dfs0(1, 0);
  dfs1(1, 0, false);
  scanf("%d", &m);
  for (int i = 1; i <= m; i++) {
    int q;
    scanf("%d", &q);
    printf("%d\n", ans[q]);
  }
  return 0;
}
```



## 2.3 ç¬›å¡å°”æ ‘

ç¬›å¡å°”æ ‘ç”±k,vä¸¤éƒ¨åˆ†ç»„æˆï¼Œä¸Šé¢çš„ä¾‹å­ä¸­kä¸ºæ•°ç»„ä¸‹æ ‡,æ‰€ä»¥å¤©ç„¶æ˜¯å‡åºæ’åºï¼Œvä¸ºæ•°ç»„å…ƒç´ ã€‚
ç¬›å¡å°”æ ‘=å †+åŸºäºæ•°ç»„ä¸‹æ ‡çš„äºŒå‰æœç´¢æ ‘.ä»¥ä¸‹æ‹¿æœ€å°å †ä¸ºä¾‹:

1.å•çº¯å®ç°ä¸€ä¸ªæœ€å°å †ï¼Œæˆ‘ä»¬ä½¿ç”¨æ ˆä½œä¸ºè¾…åŠ©ç©ºé—´æ¥æ„é€ å †.å½“ä¸€ä¸ªæ•°ç»„å…ƒç´ è¦æ„é€ èŠ‚ç‚¹æ—¶,ä»–å¯ä»¥æˆä¸ºæ ˆé¡¶å…ƒç´ çš„å­èŠ‚ç‚¹(æ¯”æ ˆé¡¶å…ƒç´ å¤§),æˆ–è€…æˆä¸ºæ ˆé¡¶å…ƒç´ çš„çˆ¶èŠ‚ç‚¹(æ¯”æ ˆé¡¶å…ƒç´ å°)

2.è¿˜è¦å°†æœ€å°å †å˜æˆäºŒå‰æœç´¢æ ‘ã€‚ä¸€ä¸ªå·²å…¥æ ˆå…ƒç´ çš„ä¸‹æ ‡<åå…¥æ ˆå…ƒç´ çš„ä¸‹æ ‡,æ‰€ä»¥åœ¨ç¬¬ä¸€æ­¥ä¸­,å˜æˆå­èŠ‚ç‚¹çš„å…ƒç´ å¿…é¡»è¦æˆä¸ºå³èŠ‚ç‚¹;å˜æˆçˆ¶èŠ‚ç‚¹çš„å…ƒç´ ,æ ˆä¸­çš„å…ƒç´ å¿…é¡»æˆä¸ºä»–çš„å·¦å­æ ‘,è¿™æ ·æ‰ä¿æŒäº†åŸºäºä¸‹æ ‡çš„äºŒå‰æœç´¢æ ‘æ€§è´¨

![build](ç®—æ³•æ¨¡æ¿.assets/cartesian-tree2.png)

![image-20251118095917987](ç®—æ³•æ¨¡æ¿.assets/image-20251118095917987.png)

```cpp
#include <algorithm>
#include <cstring>
#include <iostream>
using namespace std;
using ll = long long;
constexpr int N = 100000 + 10, INF = 0x3f3f3f3f;

struct node {
  int idx, val, par, ch[2];// ch:å­èŠ‚ç‚¹

  friend bool operator<(node a, node b) { return a.idx < b.idx; }

  void init(int _idx, int _val, int _par) {
    idx = _idx, val = _val, par = _par, ch[0] = ch[1] = 0;
  }
} tree[N];

int root, top, stk[N];
ll ans;

int cartesian_build(int n) {  // å»ºæ ‘ï¼Œæ»¡è¶³å°æ ¹å †æ€§è´¨
  for (int i = 1; i <= n; i++) {
    int k = i - 1;
    while (tree[k].val > tree[i].val) k = tree[k].par;
    tree[i].ch[0] = tree[k].ch[1];
    tree[k].ch[1] = i;
    tree[i].par = k;
    tree[tree[i].ch[0]].par = i;
  }
  return tree[0].ch[1]; // è¿”å›0çš„å³èŠ‚ç‚¹ï¼ˆçœŸæ­£çš„æ ¹èŠ‚ç‚¹ï¼Œ0åªæ˜¯ä¸ºäº†æ„é€ è€Œå†™çš„ä¸´æ—¶èŠ‚ç‚¹ï¼‰
}

int dfs(int x) {  // ä¸€æ¬¡dfsæ›´æ–°ç­”æ¡ˆå°±å¯ä»¥äº†
  if (!x) return 0;
  int sz = dfs(tree[x].ch[0]);
  sz += dfs(tree[x].ch[1]);
  ans = max(ans, (ll)(sz + 1) * tree[x].val);
  return sz + 1;
}

int main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  int n, hi;
  while (cin >> n, n) {
    tree[0].init(0, 0, 0);
    for (int i = 1; i <= n; i++) {
      cin >> hi;
      tree[i].init(i, hi, 0);
    }
    root = cartesian_build(n);
    ans = 0;
    dfs(root);
    cout << ans << '\n';
  }
  return 0;
}
```

ä¸Šé¢çš„æ²¡ç”¨æ ˆï¼Œæ—¶é—´å¯èƒ½è¢«å¡

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

const int N = 5e4+10;
int n, k;
int b[N]; 

int gcd(int x, int y){
	return y==0? x: gcd(y, x%y);
}
//---------ä¸»è¦ä»£ç --------------------------------------
// sta[1]æ˜¯è¯¥ç¬›å¡å°”æ ‘çš„æ ¹èŠ‚ç‚¹
vector<int> ls(N), rs(N), val(N), sta(N);
void build(int n){
    int top = 0;
    for(int i=1; i<=n; i++){
        int pos = top;
        while(pos>0 && val[sta[pos]] > val[i]){
            pos--;
        }
        if(pos>0){
            rs[sta[pos]] = i;
        }
        if(pos < top){
            ls[i] = sta[pos+1];
        }
        sta[++pos] = i;
        top = pos;
    }
}
//-------------------------------------------------------------

bool dfs(int l, int r, int x, int pa){
    if(l>r) return 1;
    if(pa!=0 && val[x]%val[pa]!=0) {
        return 0;
    }
    return dfs(l, x-1, ls[x], x)&dfs(x+1, r, rs[x], x);
}

bool check(int x){
    for(int i=1; i<=n; i++){
        val[i] = b[i]+x;
        ls[i] = rs[i] = 0;
    }
    build(n);
    return dfs(1, n, sta[1], 0);
}

void solve(){
    cin>>n>>k;
    int Min = 1e9;
    for(int i=1; i<=n; i++){
    	cin>>b[i];
    	Min = min(Min, b[i]);
	}
	int g = 0;
    for(int i=1; i<n; i++){
        g = gcd(g, abs(b[i]-b[i+1]));
    }
	if(g == 0){
		cout<<k<<" "<<(1+k)*k/2<<"\n";
		return;
	}

    vector<int> d;
    for(int i=1; i*i<=g; i++){
        if(g%i==0){
            d.push_back(i);
            if(i*i!=g) d.push_back(g/i);
        }
    }

	int cnt = 0, ans=0;
	for(auto i: d){
        int x = i-Min;
        if(x<1 || x>k) continue;
        if(check(x)){
            cnt ++ ;
            ans+=x;
        }
	}
	cout<<cnt<<" "<<ans<<"\n";
}

signed main(){
	ios::sync_with_stdio(0); cin.tie(0);
    int T; cin>>T;
    while(T--) solve();
} 
```



## 2.4 çº¿æ®µæ ‘

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1e5+10;
int a[N];
int tree[N<<2];
int tag[N<<2];

int ls(int p) {return p<<1;}
int rs(int p) {return p<<1|1;}

void push_up(int p)
{
    tree[p]=tree[ls(p)]+tree[rs(p)];
}

void build(int p,int l,int r)
{
    tag[p]=0;
    int mid = l+r>>1;
    if(l==r) 
    {
        tree[p]=a[l]; ///tree[l]=a[l];
        return ;
    }
    build(ls(p), l, mid);
    build(rs(p), mid+1, r);
    push_up(p);
}

void addtag(int p,int k,int l,int r)
{
    tag[p]+=k;
    tree[p]+=(r-l+1)*k;
}

void push_down(int p, int l, int r)
{
    //if(l==r) return;
    if(tag[p])
    {
        int mid = l+r>>1;
        addtag(ls(p),tag[p],l,mid);
        addtag(rs(p),tag[p],mid+1,r);
        tag[p]=0;///
    }
}
void update(int p, int L, int R, int l, int r, int k)
{
    if(L<=l && R>=r)
    {
        addtag(p,k,l,r);
        return;
    }
    push_down(p,l,r);//////////
    int mid  = l+r>>1;
    if(L<=mid) update(ls(p), L, R, l, mid, k);
    if(R>=mid+1) update(rs(p), L, R, mid+1, r, k);
    push_up(p);////
}

int query(int p, int L, int R, int l, int r)
{
    int ans = 0;
    if(L<=l && R>=r)
    {
        return tree[p];
    }
    push_down(p,l,r);
    int mid = l+r>>1;
    if(L<=mid) ans += query(ls(p),L,R,l,mid);
    if(R>=mid+1) ans +=query(rs(p),L,R,mid+1,r);
    return ans;
}

signed main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    build(1,1,n);
    while(m--)
    {
        
        int u,v,w;
        cin>>u>>v>>w;
        if(u == 1) 
        {
            int k;
            cin>>k;
            update(1,v,w,1,n,k);
        }
        else 
        {
            //for(int i=1;i<=20;i++) cout<<tree[i]<<" ";
            cout<<query(1,v,w,1,n)<<"\n";
        }
    }
}
```





# ä¸‰ã€æ•°è®º

## 3.1 æœ€å¤§å…¬çº¦æ•°ä¸æœ€å°å…¬å€æ•°

æœ€å¤§å…¬çº¦æ•°æœ‰å¦‚ä¸‹æ€§è´¨ï¼š

- (ğ‘~1~,â€¦,ğ‘~ğ‘›~) =(|ğ‘~1~|,â€¦,|ğ‘~ğ‘›~|)![(a_1,\dots,a_n)=(|a_1|,\dots,|a_n|)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- (ğ‘,ğ‘) =(ğ‘,ğ‘)![(a,b)=(b,a)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- è‹¥ ğ‘ â‰ 0![a\ne 0](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œåˆ™ (ğ‘,0) =(ğ‘,ğ‘) =|ğ‘|![(a,0)=(a,a)=|a|](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- (ğ‘ğ‘ +ğ‘Ÿ,ğ‘) =(ğ‘Ÿ,ğ‘)![(bq+r,b)=(r,b)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- (ğ‘~1~,â€¦,ğ‘~ğ‘›~) =((ğ‘~1~,ğ‘~2~),ğ‘~3~,â€¦,ğ‘~ğ‘›~)![(a_1,\dots,a_n)=((a_1,a_2),a_3,\dots,a_n)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ã€‚è¿›è€Œ âˆ€1 <ğ‘˜ <ğ‘› âˆ’1, (ğ‘~1~,â€¦,ğ‘~ğ‘›~) =((ğ‘~1~,â€¦,ğ‘~ğ‘˜~),(ğ‘~ğ‘˜+1~,â€¦,ğ‘~ğ‘›~))![\forall 1<k<n-1,~(a_1,\dots,a_n)=((a_1,\dots,a_k),(a_{k+1},\dots,a_n))](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- å¯¹ä¸å…¨ä¸º 0![0](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) çš„æ•´æ•° ğ‘~1~,â€¦,ğ‘~ğ‘›~![a_1,\dots,a_n](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) å’Œéé›¶æ•´æ•° ğ‘š![m](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œ(ğ‘šğ‘~1~,â€¦,ğ‘šğ‘~ğ‘›~) =|ğ‘š|(ğ‘~1~,â€¦,ğ‘~ğ‘›~)![(ma_1,\dots,ma_n)=|m|(a_1,\dots,a_n)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- å¯¹ä¸å…¨ä¸º 0![0](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) çš„æ•´æ•° ğ‘~1~,â€¦,ğ‘~ğ‘›~![a_1,\dots,a_n](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œè‹¥ (ğ‘~1~,â€¦,ğ‘~ğ‘›~) =ğ‘‘![(a_1,\dots,a_n)=d](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œåˆ™ (ğ‘~1~/ğ‘‘,â€¦,ğ‘~ğ‘›~/ğ‘‘) =1![(a_1/d,\dots,a_n/d)=1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- (ğ‘^ğ‘›^,ğ‘^ğ‘›^) =(ğ‘,ğ‘)^ğ‘›^![(a^n,b^n)=(a,b)^n](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ã€‚
- (a, b, c)  |ï¼ˆ|a-b|, |b-c|, |c-a|)
- (a, b, c) = (|a-b|, |b-c|,  c)

æœ€å¤§å…¬çº¦æ•°è¿˜æœ‰å¦‚ä¸‹ä¸äº’ç´ ç›¸å…³çš„æ€§è´¨ï¼š

- è‹¥ ğ‘|ğ‘ğ‘![b|ac](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) ä¸” (ğ‘,ğ‘) =1![(a,b)=1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œåˆ™ ğ‘ âˆ£ğ‘![b\mid c](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- è‹¥ ğ‘|ğ‘![b|c](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ã€ğ‘|ğ‘![a|c](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) ä¸” (ğ‘,ğ‘) =1![(a,b)=1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œåˆ™ ğ‘ğ‘ âˆ£ğ‘![ab\mid c](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- è‹¥ (ğ‘,ğ‘) =1![(a,b)=1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œåˆ™ (ğ‘,ğ‘ğ‘) =(ğ‘,ğ‘)![(a,bc)=(a,c)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- è‹¥ (ğ‘~ğ‘–~,ğ‘~ğ‘—~) =1, âˆ€1 â‰¤ğ‘– â‰¤ğ‘›,1 â‰¤ğ‘— â‰¤ğ‘š![(a_i,b_j)=1,~\forall 1\leq i\leq n,1\leq j\leq m](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œåˆ™ (âˆ~ğ‘–~ğ‘~ğ‘–~,âˆ~ğ‘—~ğ‘~ğ‘—~) =1![\left(\prod_i a_i,\prod_j b_j\right)=1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ã€‚ç‰¹åˆ«åœ°ï¼Œè‹¥ (ğ‘,ğ‘) =1![(a,b)=1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œåˆ™ (ğ‘^ğ‘›^,ğ‘^ğ‘š^) =1![(a^n,b^m)=1](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- å¯¹æ•´æ•° ğ‘~1~,â€¦,ğ‘~ğ‘›~![a_1,\dots,a_n](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œè‹¥ âˆƒğ‘£ âˆˆğ™, âˆ~ğ‘–~ğ‘~ğ‘–~ =ğ‘£^ğ‘š^![\exists v\in \mathbf{Z},~\prod_i a_i=v^m](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œä¸” (ğ‘~ğ‘–~,ğ‘~ğ‘—~) =1, âˆ€ğ‘– â‰ ğ‘—![(a_i,a_j)=1,~\forall i\ne j](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œåˆ™ âˆ€1 â‰¤ğ‘– â‰¤ğ‘›, ^ğ‘š^âˆšğ‘~ğ‘–~ âˆˆğ™![\forall 1\leq i\leq n,~\sqrt[m]{a_i}\in\mathbf{Z}](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ã€‚
  (eg. a={4,9,25}, v=30, m=2)

æœ€å°å…¬å€æ•°æœ‰å¦‚ä¸‹æ€§è´¨ï¼š

- [ğ‘~1~,â€¦,ğ‘~ğ‘›~] =[|ğ‘~1~|,â€¦,|ğ‘~ğ‘›~|]![[a_1,\dots,a_n]=[|a_1|,\dots,|a_n|]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- [ğ‘,ğ‘] =[ğ‘,ğ‘]![[a,b]=[b,a]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- è‹¥ ğ‘ â‰ 0![a\ne 0](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œåˆ™ [ğ‘,1] =[ğ‘,ğ‘] =|ğ‘|![[a,1]=[a,a]=|a|](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- è‹¥ ğ‘ âˆ£ğ‘![a\mid b](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œåˆ™ [ğ‘,ğ‘] =|ğ‘|![[a,b]=|b|](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- [ğ‘~1~,â€¦,ğ‘~ğ‘›~] =[[ğ‘~1~,ğ‘~2~],ğ‘~3~,â€¦,ğ‘~ğ‘›~]ã€‚è¿›è€Œ âˆ€1 <ğ‘˜ <ğ‘› âˆ’1, [ğ‘~1~,â€¦,ğ‘~ğ‘›~] =[[ğ‘~1~,â€¦,ğ‘~ğ‘˜~],[ğ‘~ğ‘˜+1~,â€¦,ğ‘~ğ‘›~]]
- è‹¥ ğ‘~ğ‘–~ âˆ£ğ‘š, âˆ€1 â‰¤ğ‘– â‰¤ğ‘›![a_i\mid m,~\forall 1\leq i\leq n](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼Œåˆ™ [ğ‘1,â€¦,ğ‘ğ‘›] âˆ£ğ‘š![[a_1,\dots,a_n]\mid m](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- [ğ‘šğ‘~1~,â€¦,ğ‘šğ‘~ğ‘›~] =|ğ‘š|[ğ‘~1~,â€¦,ğ‘~ğ‘›~]![[ma_1,\dots,ma_n]=|m|[a_1,\dots,a_n]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- [ğ‘,ğ‘,ğ‘]\[ğ‘ğ‘,ğ‘ğ‘,ğ‘ğ‘\] =\[ğ‘,ğ‘\]\[ğ‘,ğ‘\][ğ‘,ğ‘]![[a,b,c][ab,bc,ca]=[a,b][b,c][c,a]](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- [ğ‘^ğ‘›^,ğ‘^ğ‘›^] =[ğ‘,ğ‘]^ğ‘›^![[a^n,b^n]=[a,b]^n](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ã€‚

æœ€å¤§å…¬çº¦æ•°å’Œæœ€å°å…¬å€æ•°å¯ä»¥ç»„åˆå‡ºå¾ˆå¤šå¥‡å¦™çš„ç­‰å¼ï¼Œå¦‚ï¼š

- (ğ‘,ğ‘)[ğ‘,ğ‘] =|ğ‘ğ‘|![(a,b)[a,b]=|ab|](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- (ğ‘ğ‘,ğ‘ğ‘,ğ‘ğ‘)[ğ‘,ğ‘,ğ‘] =|ğ‘ğ‘ğ‘|![(ab,bc,ca)[a,b,c]=|abc|](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ï¼›
- (ğ‘,ğ‘,ğ‘)^2^/(ğ‘,ğ‘)(ğ‘,ğ‘)(ğ‘,ğ‘) =[ğ‘,ğ‘,ğ‘]^2^/\[ğ‘,ğ‘\]\[ğ‘,ğ‘\][ğ‘,ğ‘]![\dfrac{(a,b,c)^2}{(a,b)(b,c)(a,c)}=\dfrac{[a,b,c]^2}{[a,b][b,c][a,c]}](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)ã€‚

è¿™äº›æ€§è´¨å‡å¯é€šè¿‡å®šä¹‰æˆ– [å”¯ä¸€åˆ†è§£å®šç†](https://oi-wiki.org/math/number-theory/basic/#ç®—æœ¯åŸºæœ¬å®šç†) è¯æ˜ï¼Œå…¶ä¸­ä½¿ç”¨å”¯ä¸€åˆ†è§£å®šç†çš„è¯æ˜æ›´å®¹æ˜“ç†è§£ã€‚



## 3.2 çŸ©é˜µå¿«é€Ÿå¹‚

```cpp
struct Matrix
{
    int a[MM][MM];
    Matrix()
    {
        memset(a,0,sizeof(a));
    }
    void init()
    {
        memset(a,0,sizeof(a));
    }
    Matrix operator *(const Matrix &X)
    {
        Matrix res;
 
        for(int i = 0; i < (1 << n); ++i)
        {
            for(int j = 0; j < (1 << n); ++j)
            {
                res.a[i][j] = -1e18;
                for(int k = 0; k < (1 << n); ++k)
                {
                    // ä¸ªäººç†è§£ï¼šå…ˆæ‰¾åˆ°è¿™ä¸ªå…³ç³»ï¼Œå†æŠŠå®ƒå¥—è¿›çŸ©é˜µé‡Œ
                    res.a[i][j] = max(res.a[i][j],a[i][k] + X.a[k][j]);
                }
            }
        }
        return res;
    }
    int getmax()
    {
        int res = 0;
        for(int i = 0; i < (1 << n); ++i)
        {
            for(int j = 0; j < (1 << n); ++j)
            {
                res = max(res,a[i][j]);
            }
        }
        return res;
    }
    void print()
    {
        for(int i = 0; i < (1 << n); ++i)
        {
            for(int j = 0; j < (1 << n); ++j)
            {
                if(a[i][j] >= 0) cout << a[i][j] << " ";
                else cout << "-1 ";
            }
            cout << endl;
        }
    }
};
inline Matrix ksm(Matrix x,int k)
{
    Matrix ans;ans.init();
    while(k)
    {
        if(k&1) ans = ans * x;
        x = x * x;
        k >>= 1;
    }
    return ans;
}
```

```cpp
struct Matrix{
    int mat[MN][MN];

    Matrix(int x=0){
        memset(mat,0,sizeof(mat));
        if(!x) return;
        for(int i=0;i<MN;i++) mat[i][i]=x;
    }

    Matrix operator*(const Matrix x)const{
        Matrix ret;
        for(int i=0;i<MN;i++){
            for(int j=0;j<MN;j++){
                for(int k=0;k<MN;k++){
                    ret.mat[i][j]+=mat[i][k]*x.mat[k][j];
                }
            }
        }
        return ret;
    }

};

Matrix ksm(Matrix a,int b){
    Matrix ret(1);
    while(b){
        if(b&1) ret=ret*a;
        a=a*a;
        b>>=1;
    }
    return ret;
}

```



## 3.3 é€†å…ƒ

```cpp
// Binary exponentiation.
int pow(int a, int b, int m) {
  long long res = 1, po = a;
  for (; b; b >>= 1) {
    if (b & 1) res = res * po % m;
    po = po * po % m;
  }
  return res;
}

// Returns the modular inverse of a prime modulo p.
int inverse(int a, int p) { return pow(a, p - 2, p); }
```

