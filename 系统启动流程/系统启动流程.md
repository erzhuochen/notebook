## 一、CPU，BIOS与UEFI的启动过程

### 开机过程：
按下主机的电源键后，主板会向电源组发出信号，接收到信号后，电源会提供合适的电压给计算机。当主板收到电源正常启动的信号后，主板开始启动，主板上电后开始初始化其固件（firmware）。固件是一些固化在芯片组上的程序，它会试图去启动 CPU。CPU重置所有寄存器数据，并设置初始化数据。如果启动失败（例如 CPU 坏了或没插好），计算机就会死机并给出错误提示（如某些版本的主板固件会发出蜂鸣警告）。这种状态称为“zoombie-with-fans”。
如果前一个阶段未出错，就开始加电工作，在多 CPU 或多核 CPU 情况下，某一个 CPU 会被随机选取作为启动 CPU（bootstrap processor，BSP）运行 BIOS 内部的程序。其余的 CPU（application processor，AP）保持停机直到操作系统内核显式地使用它们。
这个初始化数据在X86架构里如下所示：

```text
    IP          0xfff0
    CS selector 0xf000
    CS base     0xffff0000
    IP/EIP (Instruction Pointer) : 指令指针寄存器，记录将要执行的指令在代码段内的偏移地址
    CS（Code Segment Register）：代码段寄存器，指向CPU当前执行代码在内存中的区域（定义了存放代码的存储器的起始地址）
```

实模式采取内存段来管理 0 – 0xFFFFF的这1M内存空间，但是由于只有16位寄存器，所以最大地址只能表示为0xFFFFF（64KB)，因此不得不采取将内存按段划分为64KB的方式来充分利用1M空间。也就是上所示的，采取段选择子 + 偏移量的表示法。这种方法在保护模式中对于页的设计上也沿用了下来，可谓祖传的智慧了。该部分由硬件完成，通过计算访问0XFFFF0，如果该位置没有可执行代码则计算机无法启动。如果有，则执行该部分代码，这里也就是我们故事的开始，BIOS程序了。

### BIOS启动过程：
简单来说 BIOS 也是一段程序代码，但是它比较特殊，它是 CPU 启动后执行的第一段代码，存储在 PC 设备中的只读存储器（ROM）中，主要完成检测内存、显卡等一系列硬件设备和建立中断向量表（IVT，Interrupt Vector Table）的工作。

- **上电自检**（POST）：BIOS进行硬件自检，包括内存、硬盘、键盘等设备，确保系统硬件正常工作。
    
- **加载BIOS设置**：BIOS读取存储在CMOS中的配置参数，如启动顺序、硬盘设置等。
    
- **查找引导设备**：BIOS按照设置的启动顺序查找引导设备（如硬盘、光驱、USB等）。
	
- **加载主引导记录**（MBR）：MBR(Master boot Record， 主引导记录)是硬盘的第一个扇区，通常为512字节大小，存储了启动所需的重要信息。**BIOS加载的第一个可引导设备是MBR**。MBR的主要作用有两个：
	- 分区表：MBR包含一个分区表，指明了硬盘上各个分区的起始位置和大小
	- 引导程序（Bootloader)：MBR的最后部分包含一个小型的引导程序，称为主引导加载程序（Primary Bootloader）。该程序的任务是引导操作系统的加载。
    
- **加载Bootloader**：当BIOS读取并找到MBR后，它会从MBR中提取出引导程序(Bootloader)的代码，并将控制权交给该引导程序。常见的Bootloader：
	- windows：NTLDR或OBBTMGR
	- linux：GRUB(Grand Unified Bootloader) 第二部分详细介绍
	
- **加载操作系统**：Bootloader启动后，会将操作系统的内核加载到内存中
    

### UEFI启动过程：

- 硬件初始化：UEFI固件初始化系统硬件设备。
    
- 执行UEFI固件：UEFI执行固件中的初始化代码，加载存储在非易失性存储器中的UEFI配置。
    
- 加载引导管理器：UEFI查找并加载引导管理器（通常是EFI分区中的启动文件）。
    
- 执行操作系统启动程序：引导管理器加载并执行操作系统的启动程序。
    

## 二、GRUB的启动过程

GRUB（GRand Unified Bootloader）是常用的开源引导加载程序，广泛用于Linux系统。它的启动过程分为多个阶段：

### GRUB启动过程：

#### 阶段1：主引导记录（MBR）：

- BIOS从MBR加载GRUB的第一个阶段引导代码。
    
- 该阶段代码加载GRUB的第二阶段引导程序。
    

#### 阶段1.5（可选）：

- GRUB 1.5阶段代码通常存储在MBR和分区之间的未分配空间中。
    
- 该阶段负责识别文件系统和加载阶段2代码。
    

#### 阶段2：

- 加载GRUB配置文件（如grub.cfg）。
    
- 显示GRUB菜单，允许用户选择操作系统或内核。
    
- 加载并执行选定的操作系统内核。
    

#### 示例GRUB配置文件（grub.cfg）：
这是旧版grub legacy的格式，比较简单
```bash

set default=0
set timeout=5

menuentry 'Ubuntu' {
    set root='(hd0,1)'
    linux /vmlinuz root=/dev/sda1 ro quiet splash
    initrd /initrd.img
}

menuentry 'Windows 10' {
    set root='(hd0,2)'
    chainloader +1
}
```
## 三、Bootloader的启动过程

Bootloader是负责加载操作系统内核的程序，GRUB是其中一种流行的Bootloader。

### Bootloader启动过程：

- 加载内核：从GRUB菜单选择操作系统后，Bootloader加载内核到内存中。
    
- 传递参数：Bootloader传递内核参数（如启动选项）并将控制权交给内核。
    
- 初始化内核：内核开始执行，初始化硬件和系统资源。
    
- 启动用户空间：内核启动init系统，加载系统服务和应用程序，进入操作系统环境。
    

#### 示例GRUB命令加载Linux内核：

```bash
grub> set root=(hd0,1)
grub> linux /vmlinuz root=/dev/sda1 ro quiet splash
grub> initrd /initrd.img
grub> boot
```

## 总结

本文详细介绍了计算机系统的启动流程，包括BIOS/UEFI的硬件初始化和引导过程、GRUB引导加载程序的分阶段启动过程，以及Bootloader加载操作系统内核的过程。通过掌握这些关键步骤和配置技巧，运维人员可以更好地理解和管理系统启动，提高系统的可用性和稳定性。

# 更详细的文章
## 1 [实模式](https://zhida.zhihu.com/search?content_id=244336077&content_type=Article&match_order=1&q=%E5%AE%9E%E6%A8%A1%E5%BC%8F&zhida_source=entity)与[保护模式](https://zhida.zhihu.com/search?content_id=244336077&content_type=Article&match_order=1&q=%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F&zhida_source=entity)

实模式（Real Mode)：又名 Real Address Mode，在此模式下地址访问的是真实地内存地址所在位置。在此模式下，可以使用20位（1MB）的地址空间，软件可以不受限制的操作所有地址的空间和IO设备。

保护模式（Protected Mode)：又名 Protected Virtual Address Mode，采用虚拟内存、页等机制对内存进行了保护，比起实模式更为安全可靠，同时也增加了灵活性和扩展性。

## 2 从启动电源到[BIOS](https://zhida.zhihu.com/search?content_id=244336077&content_type=Article&match_order=1&q=BIOS&zhida_source=entity)

![](https://pic3.zhimg.com/v2-21da2ad9899330fc3899f744c878d59c_1440w.jpg)

按下主机的电源键后，主板会向电源组发出信号，接收到信号后，电源会提供合适的电压给计算机。当主板收到电源正常启动的信号后，主板开始启动，主板上电后开始初始化其固件（firmware）。固件是一些固化在芯片组上的程序，它会试图去启动 CPU。CPU重置所有寄存器数据，并设置初始化数据。如果启动失败（例如 CPU 坏了或没插好），计算机就会死机并给出错误提示（如某些版本的主板固件会发出蜂鸣警告）。这种状态称为“zoombie-with-fans”。

如果前一个阶段未出错，就开始加电工作，在多 CPU 或多核 CPU 情况下，某一个 CPU 会被随机选取作为启动 CPU（bootstrap processor，BSP）运行 BIOS 内部的程序。其余的 CPU（application processor，AP）保持停机直到操作系统内核显式地使用它们。

这个初始化数据在X86架构里如下所示：

```text
    IP          0xfff0
    CS selector 0xf000
    CS base     0xffff0000
    IP/EIP (Instruction Pointer) : 指令指针寄存器，记录将要执行的指令在代码段内的偏移地址
    CS（Code Segment Register）：代码段寄存器，指向CPU当前执行代码在内存中的区域（定义了存放代码的存储器的起始地址）
```

实模式采取内存段来管理 0 – 0xFFFFF的这1M内存空间，但是由于只有16位寄存器，所以最大地址只能表示为0xFFFFF（64KB)，因此不得不采取将内存按段划分为64KB的方式来充分利用1M空间。也就是上所示的，采取段选择子 + 偏移量的表示法。这种方法在保护模式中对于页的设计上也沿用了下来，可谓祖传的智慧了。该部分由硬件完成，通过计算访问0XFFFF0，如果该位置没有可执行代码则计算机无法启动。如果有，则执行该部分代码，这里也就是我们故事的开始，BIOS程序了。

## 3 BIOS启动

简单来说 BIOS 也是一段程序代码，但是它比较特殊，它是 CPU 启动后执行的第一段代码，存储在 PC 设备中的只读存储器（ROM）中，主要完成检测内存、显卡等一系列硬件设备和建立[中断向量表](https://zhida.zhihu.com/search?content_id=244336077&content_type=Article&match_order=1&q=%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8&zhida_source=entity)（IVT，Interrupt Vector Table）的工作。

ROM 其实也一块内存，它会被映射到 CPU 实模式下所能访问的 1MB 物理内存空间的顶部，即地址 0xF000:0000 ~ 0xF000:FFFF。

BIOS主要包括以下内存映射：

```text
    0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table
    0x00000400 - 0x000004FF - BIOS Data Area
    0x00000500 - 0x00007BFF - Unused
    0x00007C00 - 0x00007DFF - Our Bootloader
    0x00007E00 - 0x0009FFFF - Unused
    0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory
    0x000B0000 - 0x000B7777 - Monochrome Video Memory
    0x000B8000 - 0x000BFFFF - Color Video Memory
    0x000C0000 - 0x000C7FFF - Video ROM BIOS
    0x000C8000 - 0x000EFFFF - BIOS Shadow Area
    0x000F0000 - 0x000FFFFF - System BIOS
```

其中最重要的莫过于中断向量表和中断服务程序。BIOS程序在内存最开始的位置（0x00000）用1 KB的内存空间（0x00000～0x003FF）构建中断向量表，在紧挨着它的位置用256字节的内存空间构建BIOS数据区（0x00400～0x004FF），并在大约57 KB以后的位置（0x0E05B）加载了8 KB左右的与中断向量表相应的若干中断服务程序。中断向量表中有256个中断向量，每个中断向量占4字节，其中两个字节是CS的值，两个字节是IP的值。每个中断向量都指向一个具体的中断服务程序。

BIOS程序会选择一个启动设备，并将控制权转交给启动扇区中的代码。主要工作即使用中断向量和中断服务程序完成BootLoader的加载，最终将boot.img加载至0X7C00的位置启动。Linux内核通过Boot Protocol定义(Documentation/x86/boot.rst)如何实现该引导程序，有如GRUB 2和syslinux等具体实现方式，这里仅介绍GRUB2。

**BIOS 启动过程：**

1. 当 X86 架构的 PC 在开机上电的一瞬间，CPU 中的 CS 和 IP 寄存器就被设置成了 0xF000:FFF0（这个地址就是 BIOS 代码所在内存区域），这个地址指向了 CPU 执行第一条指令的位置。而在这个地址里只存放了一条非常简单的跳转指令 jmp far f000:e05b，然后程序就跳转到了 BIOS 代码中的另外一个地址 f000:e05b 处开始接着往下执行。
2. 接下来，BIOS 就马不停蹄地检测内存、显卡等外设信息，当硬件检测通过之后，就在内存的物理内存的起始位置 0x000 ~ 0x3FF （刚好 1KB 的内存空间)建立中断向量表（IVT），如上图物理内存最底部的所示。x86 中断向量表中有 256 个中断向量，每个中断向量用 4 个字节来表示（CS 用两个字节表示，IP 也用两个字节表示），通过中断向量中保存的 CS:IP 地址就可以跳转到对应的中断处理程序去处理中断请求信号。
3. 最后，BIOS 将启动磁盘中的第 1 个扇区（[MBR](https://zhida.zhihu.com/search?content_id=244336077&content_type=Article&match_order=1&q=MBR&zhida_source=entity) 扇区，Master Boot Record）的 512 个字节的数据加载到物理内存地址为 0x7C00 ~ 0x7E00 的区域，然后程序就跳转到 0x7C00 处开始执行，至此，BIOS 就完成了所有的工作，将控制权转交到了 MBR 中的代码。

## 4 MBR 扇区

boot.img由boot.S编译而成，512字节，安装在启动盘的第一个扇区，即MBR。由于空间有限，其代码十分简单，仅仅是起到一个引导的作用，指向后续的核心镜像文件，即core.img。core.img包括很多重要的部分，如lzma_decompress.img、diskboot.img、kernel.img等，

MBR（Master Boot Record）扇区是启动磁盘中的第 1 个扇区，它主要由三部分组成：第一部分是一段引导程序，主要用来加载启动内核所需 Bootloader 程序；第二部分是当前启动磁盘的分区表；第三部分是标识 MBR 扇区的魔数 0x55 和 0xAA。

BIOS 读完磁盘上的 MBR 之后会把它拷贝到内存 `0x7C00` 地址处，然后 CPU 跳转到该内存地址执行 MBR 里的指令。事实上，被复制到物理内存的内容就是 Boot Loader。常见的 Boot Loader 有 grub、lilo、spfdisk。

![](https://pica.zhimg.com/v2-6addb00650a70b33ae9d8c9facc60682_1440w.jpg)

## 5 Bootloader 加载程序

Bootloader 是一段用来将 Linux Kernel 镜像文件加载到物理内存中指定地址的程序，这里所指的 Bootloader 是广义上概念，其实它还可以细分成两个独立的 bootloader：

第一个 bootloader：由 MBR 扇区中的前 446 个字节构成，作用是找到第二个 bootloader 并将其加载到物理内存中，并跳转到第二个 bootloader 中执行。

第二个 bootloader：这个 bootloader 位于启动盘中 MBR 扇区之后，根据 bootloader 代码的大小可能会占用一个或多个磁盘分区，它的主要作用就是找到磁盘中存放的 Linux Kernel 镜像文件以及 initrd 文件（如果在内核命令行参数中指定了的话），并将其加载到物理内存当中。

注：initrd 是 initialized ram disk 的意思。主要用于加载硬件驱动模块，辅助内核的启动，挂载真正的根文件系统。

上述这两个 bootloader 程序合在一起就构成了我们在 Linux 系统中经常用到的两个 Bootloader 程序，LILO（Linux Loader）或者是 GRUB（Grand Unified Boot Loader）。

GRUB 是我们现在 Linux 发行版系统中最常用到的 Bootloader，它的优势在于它可以识别 Linux 文件系统，例如 ext3，ext4 格式的文件系统。不像 LILO 只能从原始的磁盘扇区中加载 Linux Kernel 镜像，GRUB 可以从 ext3 或者 ext4 格式文件系统的磁盘分区中加载 Linux Kernel 镜像。

x86 系统中 Bootloader 加载内核启动的过程，如下图所示：

![](https://pic2.zhimg.com/v2-82869dbd0ce28fa672e8274b7c0a50e5_1440w.jpg)

内存盘初始化完毕之后， grub 会根据配置文件 `/boot/grub/grub.cfg` 设定的内核镜像 `vmlinuz` 所在的路径，加载内核镜像，并进行解压缩操作。此时，屏幕一般会出现 “Uncompressing Linux” 的提示。当解压缩内核完成后，屏幕一般会输出 “OK, booting the kernel”。 内核加载至内存完成后，grub 将控制权转交给内核。

## 6 内核启动

在 Boot Loader 配置了 initrd 的情况下，内核启动被分成了两个阶段：

1. 执行 initrd 的文件系统中的 `init` 脚本。此阶段，内核会将控制权交给 `init` 文件处理。`init` 主要是加载各种存储介质相关的设备驱动。当所需的驱动程序加载完毕，就会创建一个根设备，然后将根文件系统 `rootfs` 以只读的方式挂载。这一步完成后，释放未使用的内存，并转换到真正的根文件系统中，进行第 2 阶段的处理。
2. 执行真正的根文件系统中的 `/sbin/init` 进程，即系统的 1 号进程。此后，系统的控制权就全权交给 `/sbin/init` 进程了。

## 7 系统初始化

`/sbin/init` 进程是系统其它所有进程的父进程，当它接管了系统控制权后，它会根据 `/etc/inittab` 文件来执行相应的脚本，从而完成一系列的系统初始化操作。主要包括以下步骤：

1. 设置运行等级。Linux 有运行等级如下：

- 0：关机
- 1：单用户模式
- 2：无网络支持的多用户模式
- 3：有网络支持的多用户模式
- 4：保留，未使用
- 5：有网络支持、有 X-Window 支持的多用户模式
- 6：重新引导系统，即重启

- 执行 `rc.sysinit`。运行等级设置完成后，Linux 系统执行的第一个用户层文件是 `/etc/rc.d/rc.sysinit` 脚本程序，其完成的初始化操作主要包括：设置 `PATH`、设置网络配置`/etc/sysconfig/network`、启动 `swap` 分区、设置 `/proc` 等。
- 执行不同运行级别的脚本程序。根据运行级别的不同，系统会运行 `rc0.d` ~ `rc6.d` 中对应的脚本，从而完成对应的初始化工作，启动对应的服务。
- 执行 `/etc/rc.d/rc.local`。`rc.local` 是 Linux 运行用户进行个性化设置的脚本。
- 执行 `/bin/login`。进入登录状态。此时，系统已经进入到等待用户输入 `username` 和 `password` 的阶段。****