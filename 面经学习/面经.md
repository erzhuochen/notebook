# 一、AQS

AbstractQueuedSynchronizer, J.U.C(java.util.concurrent)包中Lock锁的底层实现，可用于实现多线程的同步器。

本质上来说，AQS提供了两种锁机制，分别是**排他锁**和**共享锁**。

- 排他锁：存在多线程竞争同一共享资源时，同一时刻只允许一个线程访问该共享资源，也就是多个线程中只能有一个线程获得锁资源，比如Lock中的ReentrantLock重入锁实现就是用到了AQS中的排他锁功能
- 共享锁（读锁）：只能读不能写。在同一时刻允许多个线程同时获得锁资源，比如CountDownLatch和Semaphore都是用到了AQS中的共享锁功能。

## 1.1 Lock



## 1.2 CountDownLatch

## (0) 项目代码

```java
//多线程下载
List<String> fileList = hadoopWrapper.listFile(hdfsSplitTmpPath);
LinkedBlockingDeque<String> fileDeque = new LinkedBlockingDeque<>(fileList);
CountDownLatch countDownLatch = new CountDownLatch(exportConfig.getThreadNum());
for (int num = 0; num < exportConfig.getThreadNum(); num++) {
    Thread thread = new Thread(() -> {
        String filePath = null;
        while ((filePath = fileDeque.poll()) != null) {
            if (!hadoopWrapper.existFile(filePath)) {
                continue;
            }
            String[] filePathParts = StringUtils.splitByWholeSeparator(filePath, "/");
            String[] fileNameParts = StringUtils.splitByWholeSeparator(filePathParts[filePathParts.length - 1], "-");
            if(fileNameParts == null || fileNameParts.length < 2){
                continue;
            }
            String bizCode = fileNameParts[1];
            if(localExportTmpPaths.get(bizCode) == null){
                continue;
            }
            boolean getSuccess = hadoopWrapper.get(filePath, localExportTmpPaths.get(bizCode));
            if (!getSuccess) {
                String errMsg = String.format("get file from hdfs to local error,src path:%s,target path:%s",
                        filePath, localExportTmpPaths.get(bizCode));
                exportJob.setErrCode(ErrorEnum.GET_FILE_FROM_HDFS_ERROR.getCode());
                exportJob.setErrMsg(errMsg);
                log.error(errMsg);
                throw new RuntimeException(errMsg);
            }
        }
        countDownLatch.countDown();
    });
    thread.start();
}
countDownLatch.await();

log.info("end get split file from hdfs...");
long costTime = TimeUtil.diffSecondsNow(startTime);
log.info("getSplitFileFromHdfs cost time:{}s", costTime);
```

### (1) 概念

`CountDownLatch`是一个同步工具类，用来协调多个进程之间的同步，或者说起到线程之间的通信（而不是作互斥的作用）。

`CountDownLatch`能够使一个线程在等待另一个线程完成各自工作之后，再继续执行。使用一个计数器进行实现。计数器初始值为线程的数量。当每一个线程完成自己任务后，计数器的值就会减一。当计数器的值为0时，表示所有的线程都已经完成了任务，然后在`CountDownLatch`上等待的线程就可以恢复执行接下来的任务。



### (2) 方法

- CountDownLatch(int count)：count为计数器的初始值（一般需要多少个线程执行，count就设为几）。
- countDown(): 每调用一次计数器值-1，直到count被减为0，代表所有线程全部执行完毕。
- getCount()：获取当前计数器的值。
- await(): 等待计数器变为0，即等待所有异步线程执行完毕。
- boolean await(long timeout, TimeUnit unit)： 此方法与await()区别：
  ①此方法至多会等待指定的时间，超时后会自动唤醒，若 timeout 小于等于零，则不会等待
  ②boolean 类型返回值：若计数器变为零了，则返回 true；若指定的等待时间过去了，则返回 false



### (3) 两种用法

1. 某一线程在开始运行前等待n个线程执行完毕。将`CountDownLatch`的计数器初始化为`new CountDownLatch(n)`，每当一个任务线程执行完毕，就将计数器减一（`countdownLatch.countDown()`），当计数器的值变为0时，在执行`countDownLatch.await()`的线程就会被唤醒。

```java
//多线程处理文件，读取行数和文件名
LinkedBlockingDeque<String> fileDeque = new LinkedBlockingDeque<>(fileNameList);
CountDownLatch countDownLatch = new CountDownLatch(exportConfig.getThreadNum());
for (int num = 0; num < exportConfig.getThreadNum(); num++) {
    Thread thread = new Thread(() -> {
        String fileName = null;
        while ((fileName = fileDeque.poll()) != null) {
            String path = localExportTmpPath + fileName;
            String exportFilePath = CharSequenceUtil.appendIfMissingIgnoreCase(exportTargetPath, Constant.SLASH_CHARACTER) + fileName;
            File file = new File(path);
            Integer recordsNum = null;
            if (needFileRow) {
                //获取文件行数,0行的会读成1行，所以减一
                recordsNum = FileUtil.getTotalLines(file) - 1;
            }
            //填充日志对象
            ExportLog fillExportLog = converter.toExportLog(exportLog, exportJob, fileName, exportFilePath, recordsNum);
            exportLogList.add(fillExportLog);
        }
        countDownLatch.countDown();
    });
    thread.start();
}
countDownLatch.await();
```

2. 实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的`CountDownLatch(1)`，将其计算器初始化为1，多个线程在开始执行任务前首先`countDownLatch.await()`，当主线程调用`countDown()`时，计数器变为0，多个线程同时被唤醒。

```java
package com.example.demo.CountDownLatchDemo;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class CountdownLatchTest2 {
    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        final CountDownLatch cdOrder = new CountDownLatch(1);
        final CountDownLatch cdAnswer = new CountDownLatch(4);
        for (int i = 0; i < 4; i++) {
            Runnable runnable = new Runnable() {
                @Override
                public void run() {
                    try {
                        System.out.println("选手" + Thread.currentThread().getName() + "正在等待裁判发布口令");
                        cdOrder.await();
                        System.out.println("选手" + Thread.currentThread().getName() + "已接受裁判口令");
                        Thread.sleep((long) (Math.random() * 10000));
                        System.out.println("选手" + Thread.currentThread().getName() + "到达终点");
                        cdAnswer.countDown();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            };
            service.execute(runnable);
        }
        try {
            Thread.sleep((long) (Math.random() * 10000));
            System.out.println("裁判"+Thread.currentThread().getName()+"即将发布口令");
            cdOrder.countDown();
            System.out.println("裁判"+Thread.currentThread().getName()+"已发送口令，正在等待所有选手到达终点");
            cdAnswer.await();
            System.out.println("所有选手都到达终点");
            System.out.println("裁判"+Thread.currentThread().getName()+"汇总成绩排名");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        service.shutdown();
    }
}
```



## (4) 不足

`CountDownLatch`是一次性的，计算器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CoutDownLatch使用完毕后，它不能再次被使用。

## 1.3 Semaphore



# 二、fail-safe 与 fail-fast

fail-safe 和 fail-fast 是多线程并发操作集合时的一种失败处理机制。

- **fail-fast**: 快速失败。在集合遍历过程中，一旦发现容器中的数据被修改了，会立刻抛出ConcurrentModificationException异常，从而导致遍历失败。（java.util包下的集合类都是fail-fast，如HashMap, ArrayList）
- **fail-safe**: 失败安全。在这种机制下，出现集合元素的修改，不会抛出ConcurrentModificationException。原因是采用失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代是对原集合的拷贝进行遍历，所以在遍历过程中对原集合的修改并不能被迭代器检测到。（java.util.concurrent包下的容器都是fail-safe的，如ConcerrentHashMap, CopyOnWriteArrayList）



# 二、Spring开发

## 2.1 IOC

IOC(control)





































































































